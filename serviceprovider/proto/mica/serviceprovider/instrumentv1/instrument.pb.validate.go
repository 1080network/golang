// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mica/serviceprovider/instrument/v1/instrument.proto

package instrumentv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	currencyv1 "micashared/common/enums/currencyv1"

	instrumenttypev1 "micashared/common/enums/instrumenttypev1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = currencyv1.Currency(0)

	_ = instrumenttypev1.InstrumentType(0)
)

// Validate checks the field values on RegisterInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterInstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterInstrumentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterInstrumentRequestMultiError, or nil if none found.
func (m *RegisterInstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterInstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServiceProviderUserKey()); l < 30 || l > 50 {
		err := RegisterInstrumentRequestValidationError{
			field:  "ServiceProviderUserKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ServiceProviderInstrumentRef

	// no validation rules for InstrumentType

	// no validation rules for Currency

	// no validation rules for LastFour

	for idx, item := range m.GetSettledTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RegisterInstrumentRequestValidationError{
						field:  fmt.Sprintf("SettledTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RegisterInstrumentRequestValidationError{
						field:  fmt.Sprintf("SettledTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RegisterInstrumentRequestValidationError{
					field:  fmt.Sprintf("SettledTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RegisterInstrumentRequestMultiError(errors)
	}

	return nil
}

// RegisterInstrumentRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterInstrumentRequest.ValidateAll() if the
// designated constraints aren't met.
type RegisterInstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterInstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterInstrumentRequestMultiError) AllErrors() []error { return m }

// RegisterInstrumentRequestValidationError is the validation error returned by
// RegisterInstrumentRequest.Validate if the designated constraints aren't met.
type RegisterInstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterInstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterInstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterInstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterInstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterInstrumentRequestValidationError) ErrorName() string {
	return "RegisterInstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterInstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterInstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterInstrumentRequestValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	// no validation rules for OrganizationName

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on RegisterInstrumentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterInstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterInstrumentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterInstrumentResponseMultiError, or nil if none found.
func (m *RegisterInstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterInstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterInstrumentResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
		err := RegisterInstrumentResponseValidationError{
			field:  "ServiceProviderInstrumentKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	if len(errors) > 0 {
		return RegisterInstrumentResponseMultiError(errors)
	}

	return nil
}

// RegisterInstrumentResponseMultiError is an error wrapping multiple
// validation errors returned by RegisterInstrumentResponse.ValidateAll() if
// the designated constraints aren't met.
type RegisterInstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterInstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterInstrumentResponseMultiError) AllErrors() []error { return m }

// RegisterInstrumentResponseValidationError is the validation error returned
// by RegisterInstrumentResponse.Validate if the designated constraints aren't met.
type RegisterInstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterInstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterInstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterInstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterInstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterInstrumentResponseValidationError) ErrorName() string {
	return "RegisterInstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterInstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterInstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterInstrumentResponseValidationError{}

// Validate checks the field values on GetInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstrumentRequestMultiError, or nil if none found.
func (m *GetInstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Criteria.(type) {
	case *GetInstrumentRequest_ServiceProviderInstrumentKey:
		if v == nil {
			err := GetInstrumentRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
			err := GetInstrumentRequestValidationError{
				field:  "ServiceProviderInstrumentKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *GetInstrumentRequest_ServiceProviderInstrumentRef:
		if v == nil {
			err := GetInstrumentRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServiceProviderInstrumentRef
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GetInstrumentRequestMultiError(errors)
	}

	return nil
}

// GetInstrumentRequestMultiError is an error wrapping multiple validation
// errors returned by GetInstrumentRequest.ValidateAll() if the designated
// constraints aren't met.
type GetInstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstrumentRequestMultiError) AllErrors() []error { return m }

// GetInstrumentRequestValidationError is the validation error returned by
// GetInstrumentRequest.Validate if the designated constraints aren't met.
type GetInstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstrumentRequestValidationError) ErrorName() string {
	return "GetInstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstrumentRequestValidationError{}

// Validate checks the field values on Instrument with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instrument with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstrumentMultiError, or
// nil if none found.
func (m *Instrument) ValidateAll() error {
	return m.validate(true)
}

func (m *Instrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
		err := InstrumentValidationError{
			field:  "ServiceProviderInstrumentKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Updated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Updated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Updated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ServiceProviderInstrumentRef

	if l := utf8.RuneCountInString(m.GetServiceProviderUserKey()); l < 30 || l > 50 {
		err := InstrumentValidationError{
			field:  "ServiceProviderUserKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ServiceProviderUserRef

	// no validation rules for InstrumentType

	// no validation rules for Currency

	// no validation rules for LastFour

	if len(errors) > 0 {
		return InstrumentMultiError(errors)
	}

	return nil
}

// InstrumentMultiError is an error wrapping multiple validation errors
// returned by Instrument.ValidateAll() if the designated constraints aren't met.
type InstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentMultiError) AllErrors() []error { return m }

// InstrumentValidationError is the validation error returned by
// Instrument.Validate if the designated constraints aren't met.
type InstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentValidationError) ErrorName() string { return "InstrumentValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentValidationError{}

// Validate checks the field values on GetInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInstrumentResponseMultiError, or nil if none found.
func (m *GetInstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstrumentResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInstrumentResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInstrumentResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInstrumentResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInstrumentResponseMultiError(errors)
	}

	return nil
}

// GetInstrumentResponseMultiError is an error wrapping multiple validation
// errors returned by GetInstrumentResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInstrumentResponseMultiError) AllErrors() []error { return m }

// GetInstrumentResponseValidationError is the validation error returned by
// GetInstrumentResponse.Validate if the designated constraints aren't met.
type GetInstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInstrumentResponseValidationError) ErrorName() string {
	return "GetInstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInstrumentResponseValidationError{}

// Validate checks the field values on RemoveInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveInstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveInstrumentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveInstrumentRequestMultiError, or nil if none found.
func (m *RemoveInstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveInstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Criteria.(type) {
	case *RemoveInstrumentRequest_ServiceProviderInstrumentKey:
		if v == nil {
			err := RemoveInstrumentRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
			err := RemoveInstrumentRequestValidationError{
				field:  "ServiceProviderInstrumentKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *RemoveInstrumentRequest_ServiceProviderInstrumentRef:
		if v == nil {
			err := RemoveInstrumentRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServiceProviderInstrumentRef
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RemoveInstrumentRequestMultiError(errors)
	}

	return nil
}

// RemoveInstrumentRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveInstrumentRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveInstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveInstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveInstrumentRequestMultiError) AllErrors() []error { return m }

// RemoveInstrumentRequestValidationError is the validation error returned by
// RemoveInstrumentRequest.Validate if the designated constraints aren't met.
type RemoveInstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveInstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveInstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveInstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveInstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveInstrumentRequestValidationError) ErrorName() string {
	return "RemoveInstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveInstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveInstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveInstrumentRequestValidationError{}

// Validate checks the field values on RemoveInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveInstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveInstrumentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveInstrumentResponseMultiError, or nil if none found.
func (m *RemoveInstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveInstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveInstrumentResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RemoveInstrumentResponseMultiError(errors)
	}

	return nil
}

// RemoveInstrumentResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveInstrumentResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveInstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveInstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveInstrumentResponseMultiError) AllErrors() []error { return m }

// RemoveInstrumentResponseValidationError is the validation error returned by
// RemoveInstrumentResponse.Validate if the designated constraints aren't met.
type RemoveInstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveInstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveInstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveInstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveInstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveInstrumentResponseValidationError) ErrorName() string {
	return "RemoveInstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveInstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveInstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveInstrumentResponseValidationError{}

// Validate checks the field values on SearchInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchInstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchInstrumentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchInstrumentRequestMultiError, or nil if none found.
func (m *SearchInstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchInstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Criteria.(type) {
	case *SearchInstrumentRequest_ServiceProviderUserKey:
		if v == nil {
			err := SearchInstrumentRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderUserKey()); l < 30 || l > 50 {
			err := SearchInstrumentRequestValidationError{
				field:  "ServiceProviderUserKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SearchInstrumentRequestMultiError(errors)
	}

	return nil
}

// SearchInstrumentRequestMultiError is an error wrapping multiple validation
// errors returned by SearchInstrumentRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchInstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchInstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchInstrumentRequestMultiError) AllErrors() []error { return m }

// SearchInstrumentRequestValidationError is the validation error returned by
// SearchInstrumentRequest.Validate if the designated constraints aren't met.
type SearchInstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchInstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchInstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchInstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchInstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchInstrumentRequestValidationError) ErrorName() string {
	return "SearchInstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchInstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchInstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchInstrumentRequestValidationError{}

// Validate checks the field values on SearchInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchInstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchInstrumentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchInstrumentResponseMultiError, or nil if none found.
func (m *SearchInstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchInstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchInstrumentResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchInstrumentResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchInstrumentResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchInstrumentResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchInstrumentResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchInstrumentResponseMultiError(errors)
	}

	return nil
}

// SearchInstrumentResponseMultiError is an error wrapping multiple validation
// errors returned by SearchInstrumentResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchInstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchInstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchInstrumentResponseMultiError) AllErrors() []error { return m }

// SearchInstrumentResponseValidationError is the validation error returned by
// SearchInstrumentResponse.Validate if the designated constraints aren't met.
type SearchInstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchInstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchInstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchInstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchInstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchInstrumentResponseValidationError) ErrorName() string {
	return "SearchInstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchInstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchInstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchInstrumentResponseValidationError{}

// Validate checks the field values on SetPINRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetPINRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPINRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetPINRequestMultiError, or
// nil if none found.
func (m *SetPINRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPINRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pin

	switch v := m.Criteria.(type) {
	case *SetPINRequest_ServiceProviderInstrumentKey:
		if v == nil {
			err := SetPINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
			err := SetPINRequestValidationError{
				field:  "ServiceProviderInstrumentKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *SetPINRequest_ServiceProviderInstrumentRef:
		if v == nil {
			err := SetPINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServiceProviderInstrumentRef
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return SetPINRequestMultiError(errors)
	}

	return nil
}

// SetPINRequestMultiError is an error wrapping multiple validation errors
// returned by SetPINRequest.ValidateAll() if the designated constraints
// aren't met.
type SetPINRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPINRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPINRequestMultiError) AllErrors() []error { return m }

// SetPINRequestValidationError is the validation error returned by
// SetPINRequest.Validate if the designated constraints aren't met.
type SetPINRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPINRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPINRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPINRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPINRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPINRequestValidationError) ErrorName() string { return "SetPINRequestValidationError" }

// Error satisfies the builtin error interface
func (e SetPINRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPINRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPINRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPINRequestValidationError{}

// Validate checks the field values on SetPINResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetPINResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPINResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetPINResponseMultiError,
// or nil if none found.
func (m *SetPINResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPINResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SetPINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SetPINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SetPINResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SetPINResponseMultiError(errors)
	}

	return nil
}

// SetPINResponseMultiError is an error wrapping multiple validation errors
// returned by SetPINResponse.ValidateAll() if the designated constraints
// aren't met.
type SetPINResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPINResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPINResponseMultiError) AllErrors() []error { return m }

// SetPINResponseValidationError is the validation error returned by
// SetPINResponse.Validate if the designated constraints aren't met.
type SetPINResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPINResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPINResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPINResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPINResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPINResponseValidationError) ErrorName() string { return "SetPINResponseValidationError" }

// Error satisfies the builtin error interface
func (e SetPINResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPINResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPINResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPINResponseValidationError{}

// Validate checks the field values on ResetPINRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResetPINRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetPINRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResetPINRequestMultiError, or nil if none found.
func (m *ResetPINRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetPINRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OldPin

	// no validation rules for NewPin

	switch v := m.Criteria.(type) {
	case *ResetPINRequest_ServiceProviderInstrumentKey:
		if v == nil {
			err := ResetPINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
			err := ResetPINRequestValidationError{
				field:  "ServiceProviderInstrumentKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *ResetPINRequest_ServiceProviderInstrumentRef:
		if v == nil {
			err := ResetPINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServiceProviderInstrumentRef
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ResetPINRequestMultiError(errors)
	}

	return nil
}

// ResetPINRequestMultiError is an error wrapping multiple validation errors
// returned by ResetPINRequest.ValidateAll() if the designated constraints
// aren't met.
type ResetPINRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetPINRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetPINRequestMultiError) AllErrors() []error { return m }

// ResetPINRequestValidationError is the validation error returned by
// ResetPINRequest.Validate if the designated constraints aren't met.
type ResetPINRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetPINRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetPINRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetPINRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetPINRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetPINRequestValidationError) ErrorName() string { return "ResetPINRequestValidationError" }

// Error satisfies the builtin error interface
func (e ResetPINRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetPINRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetPINRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetPINRequestValidationError{}

// Validate checks the field values on ResetPINResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ResetPINResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetPINResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResetPINResponseMultiError, or nil if none found.
func (m *ResetPINResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetPINResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResetPINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResetPINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResetPINResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResetPINResponseMultiError(errors)
	}

	return nil
}

// ResetPINResponseMultiError is an error wrapping multiple validation errors
// returned by ResetPINResponse.ValidateAll() if the designated constraints
// aren't met.
type ResetPINResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetPINResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetPINResponseMultiError) AllErrors() []error { return m }

// ResetPINResponseValidationError is the validation error returned by
// ResetPINResponse.Validate if the designated constraints aren't met.
type ResetPINResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetPINResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetPINResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetPINResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetPINResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetPINResponseValidationError) ErrorName() string { return "ResetPINResponseValidationError" }

// Error satisfies the builtin error interface
func (e ResetPINResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetPINResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetPINResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetPINResponseValidationError{}

// Validate checks the field values on RemovePINRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RemovePINRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemovePINRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemovePINRequestMultiError, or nil if none found.
func (m *RemovePINRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemovePINRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Criteria.(type) {
	case *RemovePINRequest_ServiceProviderInstrumentKey:
		if v == nil {
			err := RemovePINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetServiceProviderInstrumentKey()); l < 30 || l > 50 {
			err := RemovePINRequestValidationError{
				field:  "ServiceProviderInstrumentKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *RemovePINRequest_ServiceProviderInstrumentRef:
		if v == nil {
			err := RemovePINRequestValidationError{
				field:  "Criteria",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ServiceProviderInstrumentRef
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RemovePINRequestMultiError(errors)
	}

	return nil
}

// RemovePINRequestMultiError is an error wrapping multiple validation errors
// returned by RemovePINRequest.ValidateAll() if the designated constraints
// aren't met.
type RemovePINRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemovePINRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemovePINRequestMultiError) AllErrors() []error { return m }

// RemovePINRequestValidationError is the validation error returned by
// RemovePINRequest.Validate if the designated constraints aren't met.
type RemovePINRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemovePINRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemovePINRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemovePINRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemovePINRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemovePINRequestValidationError) ErrorName() string { return "RemovePINRequestValidationError" }

// Error satisfies the builtin error interface
func (e RemovePINRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemovePINRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemovePINRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemovePINRequestValidationError{}

// Validate checks the field values on RemovePINResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RemovePINResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemovePINResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemovePINResponseMultiError, or nil if none found.
func (m *RemovePINResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemovePINResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemovePINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemovePINResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemovePINResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RemovePINResponseMultiError(errors)
	}

	return nil
}

// RemovePINResponseMultiError is an error wrapping multiple validation errors
// returned by RemovePINResponse.ValidateAll() if the designated constraints
// aren't met.
type RemovePINResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemovePINResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemovePINResponseMultiError) AllErrors() []error { return m }

// RemovePINResponseValidationError is the validation error returned by
// RemovePINResponse.Validate if the designated constraints aren't met.
type RemovePINResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemovePINResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemovePINResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemovePINResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemovePINResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemovePINResponseValidationError) ErrorName() string {
	return "RemovePINResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemovePINResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemovePINResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemovePINResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemovePINResponseValidationError{}

// Validate checks the field values on RetrieveTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetrieveTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetrieveTransactionRequestMultiError, or nil if none found.
func (m *RetrieveTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceProviderInstrumentRef

	if all {
		switch v := interface{}(m.GetDateFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetrieveTransactionRequestValidationError{
					field:  "DateFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetrieveTransactionRequestValidationError{
					field:  "DateFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDateFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetrieveTransactionRequestValidationError{
				field:  "DateFrom",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDateTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetrieveTransactionRequestValidationError{
					field:  "DateTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetrieveTransactionRequestValidationError{
					field:  "DateTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDateTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetrieveTransactionRequestValidationError{
				field:  "DateTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RetrieveTransactionRequestMultiError(errors)
	}

	return nil
}

// RetrieveTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by RetrieveTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type RetrieveTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveTransactionRequestMultiError) AllErrors() []error { return m }

// RetrieveTransactionRequestValidationError is the validation error returned
// by RetrieveTransactionRequest.Validate if the designated constraints aren't met.
type RetrieveTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveTransactionRequestValidationError) ErrorName() string {
	return "RetrieveTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RetrieveTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveTransactionRequestValidationError{}

// Validate checks the field values on RetrieveTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RetrieveTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetrieveTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetrieveTransactionResponseMultiError, or nil if none found.
func (m *RetrieveTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RetrieveTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetrieveTransactionResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetrieveTransactionResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetrieveTransactionResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RetrieveTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RetrieveTransactionResponseValidationError{
						field:  fmt.Sprintf("Transactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RetrieveTransactionResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RetrieveTransactionResponseMultiError(errors)
	}

	return nil
}

// RetrieveTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by RetrieveTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type RetrieveTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetrieveTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetrieveTransactionResponseMultiError) AllErrors() []error { return m }

// RetrieveTransactionResponseValidationError is the validation error returned
// by RetrieveTransactionResponse.Validate if the designated constraints
// aren't met.
type RetrieveTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetrieveTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetrieveTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetrieveTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetrieveTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetrieveTransactionResponseValidationError) ErrorName() string {
	return "RetrieveTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RetrieveTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetrieveTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetrieveTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetrieveTransactionResponseValidationError{}
