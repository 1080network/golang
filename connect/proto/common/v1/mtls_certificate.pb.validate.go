// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: common/v1/mtls_certificate.proto

package commonv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MTLSCertificateSignatureRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MTLSCertificateSignatureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MTLSCertificateSignatureRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MTLSCertificateSignatureRequestMultiError, or nil if none found.
func (m *MTLSCertificateSignatureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MTLSCertificateSignatureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPemCsr()) < 1 {
		err := MTLSCertificateSignatureRequestValidationError{
			field:  "PemCsr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MTLSCertificateSignatureRequestMultiError(errors)
	}

	return nil
}

// MTLSCertificateSignatureRequestMultiError is an error wrapping multiple
// validation errors returned by MTLSCertificateSignatureRequest.ValidateAll()
// if the designated constraints aren't met.
type MTLSCertificateSignatureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MTLSCertificateSignatureRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MTLSCertificateSignatureRequestMultiError) AllErrors() []error { return m }

// MTLSCertificateSignatureRequestValidationError is the validation error
// returned by MTLSCertificateSignatureRequest.Validate if the designated
// constraints aren't met.
type MTLSCertificateSignatureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MTLSCertificateSignatureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MTLSCertificateSignatureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MTLSCertificateSignatureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MTLSCertificateSignatureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MTLSCertificateSignatureRequestValidationError) ErrorName() string {
	return "MTLSCertificateSignatureRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MTLSCertificateSignatureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMTLSCertificateSignatureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MTLSCertificateSignatureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MTLSCertificateSignatureRequestValidationError{}

// Validate checks the field values on MTLSCertificate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MTLSCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MTLSCertificateMultiError, or nil if none found.
func (m *MTLSCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *MTLSCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := MTLSCertificateValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIssued()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MTLSCertificateValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MTLSCertificateValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssued()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MTLSCertificateValidationError{
				field:  "Issued",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetExpiry() == nil {
		err := MTLSCertificateValidationError{
			field:  "Expiry",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	// no validation rules for PemCertificate

	// no validation rules for PemIssuingCa

	// no validation rules for PemBundle

	if len(errors) > 0 {
		return MTLSCertificateMultiError(errors)
	}

	return nil
}

// MTLSCertificateMultiError is an error wrapping multiple validation errors
// returned by MTLSCertificate.ValidateAll() if the designated constraints
// aren't met.
type MTLSCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MTLSCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MTLSCertificateMultiError) AllErrors() []error { return m }

// MTLSCertificateValidationError is the validation error returned by
// MTLSCertificate.Validate if the designated constraints aren't met.
type MTLSCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MTLSCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MTLSCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MTLSCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MTLSCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MTLSCertificateValidationError) ErrorName() string { return "MTLSCertificateValidationError" }

// Error satisfies the builtin error interface
func (e MTLSCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMTLSCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MTLSCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MTLSCertificateValidationError{}

// Validate checks the field values on GenerateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMTLSCertificateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMTLSCertificateRequestMultiError, or nil if none found.
func (m *GenerateMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCsr() == nil {
		err := GenerateMTLSCertificateRequestValidationError{
			field:  "Csr",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCsr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateRequestValidationError{
					field:  "Csr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateRequestValidationError{
					field:  "Csr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCsr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateRequestValidationError{
				field:  "Csr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRoles()) < 1 {
		err := GenerateMTLSCertificateRequestValidationError{
			field:  "Roles",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExpireInDuration

	if len(errors) > 0 {
		return GenerateMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GenerateMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateMTLSCertificateRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GenerateMTLSCertificateRequestValidationError is the validation error
// returned by GenerateMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type GenerateMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMTLSCertificateRequestValidationError) ErrorName() string {
	return "GenerateMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMTLSCertificateRequestValidationError{}

// Validate checks the field values on GenerateMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMTLSCertificateResponseMultiError, or nil if none found.
func (m *GenerateMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GenerateMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GenerateMTLSCertificateResponseValidationError is the validation error
// returned by GenerateMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type GenerateMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMTLSCertificateResponseValidationError) ErrorName() string {
	return "GenerateMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMTLSCertificateResponseValidationError{}

// Validate checks the field values on UpdateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMTLSCertificateRequestMultiError, or nil if none found.
func (m *UpdateMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := UpdateMTLSCertificateRequestValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// UpdateMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateMTLSCertificateRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// UpdateMTLSCertificateRequestValidationError is the validation error returned
// by UpdateMTLSCertificateRequest.Validate if the designated constraints
// aren't met.
type UpdateMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMTLSCertificateRequestValidationError) ErrorName() string {
	return "UpdateMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMTLSCertificateRequestValidationError{}

// Validate checks the field values on UpdateMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateMTLSCertificateResponseMultiError, or nil if none found.
func (m *UpdateMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SerialNumber

	if len(errors) > 0 {
		return UpdateMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// UpdateMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// UpdateMTLSCertificateResponseValidationError is the validation error
// returned by UpdateMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type UpdateMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMTLSCertificateResponseValidationError) ErrorName() string {
	return "UpdateMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMTLSCertificateResponseValidationError{}

// Validate checks the field values on GetMTLSCertificateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMTLSCertificateRequestMultiError, or nil if none found.
func (m *GetMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := GetMTLSCertificateRequestValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GetMTLSCertificateRequestMultiError is an error wrapping multiple validation
// errors returned by GetMTLSCertificateRequest.ValidateAll() if the
// designated constraints aren't met.
type GetMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GetMTLSCertificateRequestValidationError is the validation error returned by
// GetMTLSCertificateRequest.Validate if the designated constraints aren't met.
type GetMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMTLSCertificateRequestValidationError) ErrorName() string {
	return "GetMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMTLSCertificateRequestValidationError{}

// Validate checks the field values on GetMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMTLSCertificateResponseMultiError, or nil if none found.
func (m *GetMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GetMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by GetMTLSCertificateResponse.ValidateAll() if
// the designated constraints aren't met.
type GetMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GetMTLSCertificateResponseValidationError is the validation error returned
// by GetMTLSCertificateResponse.Validate if the designated constraints aren't met.
type GetMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMTLSCertificateResponseValidationError) ErrorName() string {
	return "GetMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMTLSCertificateResponseValidationError{}

// Validate checks the field values on SearchMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMTLSCertificateRequestMultiError, or nil if none found.
func (m *SearchMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SearchMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// SearchMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by SearchMTLSCertificateRequest.ValidateAll() if
// the designated constraints aren't met.
type SearchMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// SearchMTLSCertificateRequestValidationError is the validation error returned
// by SearchMTLSCertificateRequest.Validate if the designated constraints
// aren't met.
type SearchMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMTLSCertificateRequestValidationError) ErrorName() string {
	return "SearchMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMTLSCertificateRequestValidationError{}

// Validate checks the field values on SearchMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SearchMTLSCertificateResponseMultiError, or nil if none found.
func (m *SearchMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCertificates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchMTLSCertificateResponseValidationError{
					field:  fmt.Sprintf("Certificates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// SearchMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by SearchMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type SearchMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// SearchMTLSCertificateResponseValidationError is the validation error
// returned by SearchMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type SearchMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMTLSCertificateResponseValidationError) ErrorName() string {
	return "SearchMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMTLSCertificateResponseValidationError{}

// Validate checks the field values on ClientMTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientMTLSCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientMTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientMTLSCertificateMultiError, or nil if none found.
func (m *ClientMTLSCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientMTLSCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCertificateRefKey()); l < 30 || l > 50 {
		err := ClientMTLSCertificateValidationError{
			field:  "CertificateRefKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisplayName

	// no validation rules for CrtPem

	// no validation rules for CsrPem

	// no validation rules for RootcaBundlePem

	// no validation rules for Enabled

	if len(errors) > 0 {
		return ClientMTLSCertificateMultiError(errors)
	}

	return nil
}

// ClientMTLSCertificateMultiError is an error wrapping multiple validation
// errors returned by ClientMTLSCertificate.ValidateAll() if the designated
// constraints aren't met.
type ClientMTLSCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientMTLSCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientMTLSCertificateMultiError) AllErrors() []error { return m }

// ClientMTLSCertificateValidationError is the validation error returned by
// ClientMTLSCertificate.Validate if the designated constraints aren't met.
type ClientMTLSCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientMTLSCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientMTLSCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientMTLSCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientMTLSCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientMTLSCertificateValidationError) ErrorName() string {
	return "ClientMTLSCertificateValidationError"
}

// Error satisfies the builtin error interface
func (e ClientMTLSCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientMTLSCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientMTLSCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientMTLSCertificateValidationError{}

// Validate checks the field values on
// GenerateExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateExternalClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateExternalClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *GenerateExternalClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateExternalClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	if len(errors) > 0 {
		return GenerateExternalClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GenerateExternalClientMTLSCertificateRequestMultiError is an error wrapping
// multiple validation errors returned by
// GenerateExternalClientMTLSCertificateRequest.ValidateAll() if the
// designated constraints aren't met.
type GenerateExternalClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateExternalClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateExternalClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GenerateExternalClientMTLSCertificateRequestValidationError is the
// validation error returned by
// GenerateExternalClientMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type GenerateExternalClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateExternalClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateExternalClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateExternalClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateExternalClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateExternalClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "GenerateExternalClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateExternalClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateExternalClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateExternalClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateExternalClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on
// GenerateExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateExternalClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateExternalClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *GenerateExternalClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateExternalClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateExternalClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificateToSign()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateExternalClientMTLSCertificateResponseValidationError{
					field:  "CertificateToSign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateExternalClientMTLSCertificateResponseValidationError{
					field:  "CertificateToSign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificateToSign()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateExternalClientMTLSCertificateResponseValidationError{
				field:  "CertificateToSign",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateExternalClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GenerateExternalClientMTLSCertificateResponseMultiError is an error wrapping
// multiple validation errors returned by
// GenerateExternalClientMTLSCertificateResponse.ValidateAll() if the
// designated constraints aren't met.
type GenerateExternalClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateExternalClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateExternalClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GenerateExternalClientMTLSCertificateResponseValidationError is the
// validation error returned by
// GenerateExternalClientMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type GenerateExternalClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateExternalClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateExternalClientMTLSCertificateResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GenerateExternalClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateExternalClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateExternalClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "GenerateExternalClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateExternalClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateExternalClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateExternalClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateExternalClientMTLSCertificateResponseValidationError{}

// Validate checks the field values on
// UpdateExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateExternalClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateExternalClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *UpdateExternalClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExternalClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCertificateRefKey()); l < 30 || l > 50 {
		err := UpdateExternalClientMTLSCertificateRequestValidationError{
			field:  "CertificateRefKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisplayName

	// no validation rules for SignedCertPemFromCsr

	// no validation rules for RootcaBundlePem

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateExternalClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// UpdateExternalClientMTLSCertificateRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateExternalClientMTLSCertificateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateExternalClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExternalClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExternalClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// UpdateExternalClientMTLSCertificateRequestValidationError is the validation
// error returned by UpdateExternalClientMTLSCertificateRequest.Validate if
// the designated constraints aren't met.
type UpdateExternalClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExternalClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExternalClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExternalClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExternalClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExternalClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "UpdateExternalClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExternalClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExternalClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExternalClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExternalClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on
// UpdateExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateExternalClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateExternalClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *UpdateExternalClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateExternalClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateExternalClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateExternalClientMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateExternalClientMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateExternalClientMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateExternalClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// UpdateExternalClientMTLSCertificateResponseMultiError is an error wrapping
// multiple validation errors returned by
// UpdateExternalClientMTLSCertificateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateExternalClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateExternalClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateExternalClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// UpdateExternalClientMTLSCertificateResponseValidationError is the validation
// error returned by UpdateExternalClientMTLSCertificateResponse.Validate if
// the designated constraints aren't met.
type UpdateExternalClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateExternalClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateExternalClientMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateExternalClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateExternalClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateExternalClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "UpdateExternalClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateExternalClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateExternalClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateExternalClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateExternalClientMTLSCertificateResponseValidationError{}

// Validate checks the field values on
// SearchExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchExternalClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// SearchExternalClientMTLSCertificateRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// SearchExternalClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *SearchExternalClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchExternalClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SearchExternalClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// SearchExternalClientMTLSCertificateRequestMultiError is an error wrapping
// multiple validation errors returned by
// SearchExternalClientMTLSCertificateRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchExternalClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchExternalClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchExternalClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// SearchExternalClientMTLSCertificateRequestValidationError is the validation
// error returned by SearchExternalClientMTLSCertificateRequest.Validate if
// the designated constraints aren't met.
type SearchExternalClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchExternalClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchExternalClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchExternalClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchExternalClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchExternalClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "SearchExternalClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchExternalClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchExternalClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchExternalClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchExternalClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on
// SearchExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchExternalClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// SearchExternalClientMTLSCertificateResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// SearchExternalClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *SearchExternalClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchExternalClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchExternalClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchExternalClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCertificates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchExternalClientMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchExternalClientMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchExternalClientMTLSCertificateResponseValidationError{
					field:  fmt.Sprintf("Certificates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchExternalClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// SearchExternalClientMTLSCertificateResponseMultiError is an error wrapping
// multiple validation errors returned by
// SearchExternalClientMTLSCertificateResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchExternalClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchExternalClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchExternalClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// SearchExternalClientMTLSCertificateResponseValidationError is the validation
// error returned by SearchExternalClientMTLSCertificateResponse.Validate if
// the designated constraints aren't met.
type SearchExternalClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchExternalClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchExternalClientMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchExternalClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchExternalClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchExternalClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "SearchExternalClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchExternalClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchExternalClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchExternalClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchExternalClientMTLSCertificateResponseValidationError{}
