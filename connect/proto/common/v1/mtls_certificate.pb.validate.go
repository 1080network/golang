// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: common/v1/mtls_certificate.proto

package commonv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MTLSCertificateSignatureRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MTLSCertificateSignatureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MTLSCertificateSignatureRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MTLSCertificateSignatureRequestMultiError, or nil if none found.
func (m *MTLSCertificateSignatureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MTLSCertificateSignatureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPemCsr()) < 1 {
		err := MTLSCertificateSignatureRequestValidationError{
			field:  "PemCsr",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MTLSCertificateSignatureRequestMultiError(errors)
	}

	return nil
}

// MTLSCertificateSignatureRequestMultiError is an error wrapping multiple
// validation errors returned by MTLSCertificateSignatureRequest.ValidateAll()
// if the designated constraints aren't met.
type MTLSCertificateSignatureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MTLSCertificateSignatureRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MTLSCertificateSignatureRequestMultiError) AllErrors() []error { return m }

// MTLSCertificateSignatureRequestValidationError is the validation error
// returned by MTLSCertificateSignatureRequest.Validate if the designated
// constraints aren't met.
type MTLSCertificateSignatureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MTLSCertificateSignatureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MTLSCertificateSignatureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MTLSCertificateSignatureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MTLSCertificateSignatureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MTLSCertificateSignatureRequestValidationError) ErrorName() string {
	return "MTLSCertificateSignatureRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MTLSCertificateSignatureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMTLSCertificateSignatureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MTLSCertificateSignatureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MTLSCertificateSignatureRequestValidationError{}

// Validate checks the field values on MTLSCertificate with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MTLSCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MTLSCertificateMultiError, or nil if none found.
func (m *MTLSCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *MTLSCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := MTLSCertificateValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetIssued()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MTLSCertificateValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MTLSCertificateValidationError{
					field:  "Issued",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssued()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MTLSCertificateValidationError{
				field:  "Issued",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetExpiry() == nil {
		err := MTLSCertificateValidationError{
			field:  "Expiry",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	// no validation rules for PemCertificate

	// no validation rules for PemIssuingCa

	// no validation rules for PemBundle

	if len(errors) > 0 {
		return MTLSCertificateMultiError(errors)
	}

	return nil
}

// MTLSCertificateMultiError is an error wrapping multiple validation errors
// returned by MTLSCertificate.ValidateAll() if the designated constraints
// aren't met.
type MTLSCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MTLSCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MTLSCertificateMultiError) AllErrors() []error { return m }

// MTLSCertificateValidationError is the validation error returned by
// MTLSCertificate.Validate if the designated constraints aren't met.
type MTLSCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MTLSCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MTLSCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MTLSCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MTLSCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MTLSCertificateValidationError) ErrorName() string { return "MTLSCertificateValidationError" }

// Error satisfies the builtin error interface
func (e MTLSCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMTLSCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MTLSCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MTLSCertificateValidationError{}

// Validate checks the field values on GenerateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMTLSCertificateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMTLSCertificateRequestMultiError, or nil if none found.
func (m *GenerateMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCsr() == nil {
		err := GenerateMTLSCertificateRequestValidationError{
			field:  "Csr",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCsr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateRequestValidationError{
					field:  "Csr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateRequestValidationError{
					field:  "Csr",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCsr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateRequestValidationError{
				field:  "Csr",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetRoles()) < 1 {
		err := GenerateMTLSCertificateRequestValidationError{
			field:  "Roles",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GenerateMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GenerateMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateMTLSCertificateRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GenerateMTLSCertificateRequestValidationError is the validation error
// returned by GenerateMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type GenerateMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMTLSCertificateRequestValidationError) ErrorName() string {
	return "GenerateMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMTLSCertificateRequestValidationError{}

// Validate checks the field values on GenerateMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateMTLSCertificateResponseMultiError, or nil if none found.
func (m *GenerateMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GenerateMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GenerateMTLSCertificateResponseValidationError is the validation error
// returned by GenerateMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type GenerateMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateMTLSCertificateResponseValidationError) ErrorName() string {
	return "GenerateMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateMTLSCertificateResponseValidationError{}

// Validate checks the field values on UpdateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMTLSCertificateRequestMultiError, or nil if none found.
func (m *UpdateMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := UpdateMTLSCertificateRequestValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// UpdateMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateMTLSCertificateRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// UpdateMTLSCertificateRequestValidationError is the validation error returned
// by UpdateMTLSCertificateRequest.Validate if the designated constraints
// aren't met.
type UpdateMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMTLSCertificateRequestValidationError) ErrorName() string {
	return "UpdateMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMTLSCertificateRequestValidationError{}

// Validate checks the field values on UpdateMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateMTLSCertificateResponseMultiError, or nil if none found.
func (m *UpdateMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SerialNumber

	if len(errors) > 0 {
		return UpdateMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// UpdateMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// UpdateMTLSCertificateResponseValidationError is the validation error
// returned by UpdateMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type UpdateMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMTLSCertificateResponseValidationError) ErrorName() string {
	return "UpdateMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMTLSCertificateResponseValidationError{}

// Validate checks the field values on GetMTLSCertificateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMTLSCertificateRequestMultiError, or nil if none found.
func (m *GetMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetSerialNumber()) < 1 {
		err := GetMTLSCertificateRequestValidationError{
			field:  "SerialNumber",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GetMTLSCertificateRequestMultiError is an error wrapping multiple validation
// errors returned by GetMTLSCertificateRequest.ValidateAll() if the
// designated constraints aren't met.
type GetMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GetMTLSCertificateRequestValidationError is the validation error returned by
// GetMTLSCertificateRequest.Validate if the designated constraints aren't met.
type GetMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMTLSCertificateRequestValidationError) ErrorName() string {
	return "GetMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMTLSCertificateRequestValidationError{}

// Validate checks the field values on GetMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMTLSCertificateResponseMultiError, or nil if none found.
func (m *GetMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GetMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by GetMTLSCertificateResponse.ValidateAll() if
// the designated constraints aren't met.
type GetMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GetMTLSCertificateResponseValidationError is the validation error returned
// by GetMTLSCertificateResponse.Validate if the designated constraints aren't met.
type GetMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMTLSCertificateResponseValidationError) ErrorName() string {
	return "GetMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMTLSCertificateResponseValidationError{}

// Validate checks the field values on SearchMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMTLSCertificateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchMTLSCertificateRequestMultiError, or nil if none found.
func (m *SearchMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SearchMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// SearchMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by SearchMTLSCertificateRequest.ValidateAll() if
// the designated constraints aren't met.
type SearchMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// SearchMTLSCertificateRequestValidationError is the validation error returned
// by SearchMTLSCertificateRequest.Validate if the designated constraints
// aren't met.
type SearchMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMTLSCertificateRequestValidationError) ErrorName() string {
	return "SearchMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMTLSCertificateRequestValidationError{}

// Validate checks the field values on SearchMTLSCertificateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SearchMTLSCertificateResponseMultiError, or nil if none found.
func (m *SearchMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCertificates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchMTLSCertificateResponseValidationError{
					field:  fmt.Sprintf("Certificates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// SearchMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by SearchMTLSCertificateResponse.ValidateAll()
// if the designated constraints aren't met.
type SearchMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// SearchMTLSCertificateResponseValidationError is the validation error
// returned by SearchMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type SearchMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchMTLSCertificateResponseValidationError) ErrorName() string {
	return "SearchMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchMTLSCertificateResponseValidationError{}

// Validate checks the field values on ClientMTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClientMTLSCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClientMTLSCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClientMTLSCertificateMultiError, or nil if none found.
func (m *ClientMTLSCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *ClientMTLSCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCertificateRefKey()); l < 30 || l > 50 {
		err := ClientMTLSCertificateValidationError{
			field:  "CertificateRefKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisplayName

	// no validation rules for CrtPem

	// no validation rules for CsrPem

	// no validation rules for RootcaBundlePem

	// no validation rules for Enabled

	if len(errors) > 0 {
		return ClientMTLSCertificateMultiError(errors)
	}

	return nil
}

// ClientMTLSCertificateMultiError is an error wrapping multiple validation
// errors returned by ClientMTLSCertificate.ValidateAll() if the designated
// constraints aren't met.
type ClientMTLSCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClientMTLSCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClientMTLSCertificateMultiError) AllErrors() []error { return m }

// ClientMTLSCertificateValidationError is the validation error returned by
// ClientMTLSCertificate.Validate if the designated constraints aren't met.
type ClientMTLSCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClientMTLSCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClientMTLSCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClientMTLSCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClientMTLSCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClientMTLSCertificateValidationError) ErrorName() string {
	return "ClientMTLSCertificateValidationError"
}

// Error satisfies the builtin error interface
func (e ClientMTLSCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClientMTLSCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClientMTLSCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClientMTLSCertificateValidationError{}

// Validate checks the field values on GenerateClientMTLSCertificateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GenerateClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateClientMTLSCertificateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GenerateClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *GenerateClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisplayName

	if len(errors) > 0 {
		return GenerateClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// GenerateClientMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by
// GenerateClientMTLSCertificateRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// GenerateClientMTLSCertificateRequestValidationError is the validation error
// returned by GenerateClientMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type GenerateClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "GenerateClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on GenerateClientMTLSCertificateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GenerateClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateClientMTLSCertificateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GenerateClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *GenerateClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificateToSign()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateClientMTLSCertificateResponseValidationError{
					field:  "CertificateToSign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateClientMTLSCertificateResponseValidationError{
					field:  "CertificateToSign",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificateToSign()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateClientMTLSCertificateResponseValidationError{
				field:  "CertificateToSign",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// GenerateClientMTLSCertificateResponseMultiError is an error wrapping
// multiple validation errors returned by
// GenerateClientMTLSCertificateResponse.ValidateAll() if the designated
// constraints aren't met.
type GenerateClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// GenerateClientMTLSCertificateResponseValidationError is the validation error
// returned by GenerateClientMTLSCertificateResponse.Validate if the
// designated constraints aren't met.
type GenerateClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateClientMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "GenerateClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateClientMTLSCertificateResponseValidationError{}

// Validate checks the field values on UpdateClientMTLSCertificateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClientMTLSCertificateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *UpdateClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetCertificateRefKey()); l < 30 || l > 50 {
		err := UpdateClientMTLSCertificateRequestValidationError{
			field:  "CertificateRefKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for DisplayName

	// no validation rules for SignedCertPemFromCsr

	// no validation rules for RootcaBundlePem

	// no validation rules for Enabled

	if len(errors) > 0 {
		return UpdateClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// UpdateClientMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateClientMTLSCertificateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// UpdateClientMTLSCertificateRequestValidationError is the validation error
// returned by UpdateClientMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type UpdateClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "UpdateClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on UpdateClientMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateClientMTLSCertificateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *UpdateClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCertificate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateClientMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateClientMTLSCertificateResponseValidationError{
					field:  "Certificate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCertificate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateClientMTLSCertificateResponseValidationError{
				field:  "Certificate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// UpdateClientMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateClientMTLSCertificateResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// UpdateClientMTLSCertificateResponseValidationError is the validation error
// returned by UpdateClientMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type UpdateClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateClientMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "UpdateClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateClientMTLSCertificateResponseValidationError{}

// Validate checks the field values on SearchClientMTLSCertificateRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SearchClientMTLSCertificateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchClientMTLSCertificateRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SearchClientMTLSCertificateRequestMultiError, or nil if none found.
func (m *SearchClientMTLSCertificateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchClientMTLSCertificateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SearchClientMTLSCertificateRequestMultiError(errors)
	}

	return nil
}

// SearchClientMTLSCertificateRequestMultiError is an error wrapping multiple
// validation errors returned by
// SearchClientMTLSCertificateRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchClientMTLSCertificateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchClientMTLSCertificateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchClientMTLSCertificateRequestMultiError) AllErrors() []error { return m }

// SearchClientMTLSCertificateRequestValidationError is the validation error
// returned by SearchClientMTLSCertificateRequest.Validate if the designated
// constraints aren't met.
type SearchClientMTLSCertificateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchClientMTLSCertificateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchClientMTLSCertificateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchClientMTLSCertificateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchClientMTLSCertificateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchClientMTLSCertificateRequestValidationError) ErrorName() string {
	return "SearchClientMTLSCertificateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchClientMTLSCertificateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchClientMTLSCertificateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchClientMTLSCertificateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchClientMTLSCertificateRequestValidationError{}

// Validate checks the field values on SearchClientMTLSCertificateResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SearchClientMTLSCertificateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchClientMTLSCertificateResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SearchClientMTLSCertificateResponseMultiError, or nil if none found.
func (m *SearchClientMTLSCertificateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchClientMTLSCertificateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchClientMTLSCertificateResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchClientMTLSCertificateResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCertificates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchClientMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchClientMTLSCertificateResponseValidationError{
						field:  fmt.Sprintf("Certificates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchClientMTLSCertificateResponseValidationError{
					field:  fmt.Sprintf("Certificates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchClientMTLSCertificateResponseMultiError(errors)
	}

	return nil
}

// SearchClientMTLSCertificateResponseMultiError is an error wrapping multiple
// validation errors returned by
// SearchClientMTLSCertificateResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchClientMTLSCertificateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchClientMTLSCertificateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchClientMTLSCertificateResponseMultiError) AllErrors() []error { return m }

// SearchClientMTLSCertificateResponseValidationError is the validation error
// returned by SearchClientMTLSCertificateResponse.Validate if the designated
// constraints aren't met.
type SearchClientMTLSCertificateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchClientMTLSCertificateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchClientMTLSCertificateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchClientMTLSCertificateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchClientMTLSCertificateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchClientMTLSCertificateResponseValidationError) ErrorName() string {
	return "SearchClientMTLSCertificateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchClientMTLSCertificateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchClientMTLSCertificateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchClientMTLSCertificateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchClientMTLSCertificateResponseValidationError{}
