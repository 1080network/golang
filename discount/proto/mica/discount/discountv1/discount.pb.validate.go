// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: mica/discount/discount/v1/discount.proto

package discountv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	approvaltypev1 "micashared/common/enums/approvaltypev1"

	currencyv1 "micashared/common/enums/currencyv1"

	discounttypev1 "micashared/common/enums/discounttypev1"

	unitv1 "micashared/common/enums/unitv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = approvaltypev1.ApprovalType(0)

	_ = currencyv1.Currency(0)

	_ = discounttypev1.DiscountType(0)

	_ = unitv1.Unit(0)
)

// Validate checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionDetailsMultiError, or nil if none found.
func (m *TransactionDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ApprovalType

	if l := utf8.RuneCountInString(m.GetTransactionKey()); l < 30 || l > 50 {
		err := TransactionDetailsValidationError{
			field:  "TransactionKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPartnerKey()); l < 30 || l > 50 {
		err := TransactionDetailsValidationError{
			field:  "PartnerKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPartnerName()); l < 1 || l > 100 {
		err := TransactionDetailsValidationError{
			field:  "PartnerName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOrganizationKey()); l < 30 || l > 50 {
		err := TransactionDetailsValidationError{
			field:  "OrganizationKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OrganizationName

	if all {
		switch v := interface{}(m.GetOrganizationAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionDetailsValidationError{
					field:  "OrganizationAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionDetailsValidationError{
					field:  "OrganizationAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganizationAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionDetailsValidationError{
				field:  "OrganizationAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetStoreKey()); l < 30 || l > 50 {
		err := TransactionDetailsValidationError{
			field:  "StoreKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StoreNumber

	if all {
		switch v := interface{}(m.GetStoreAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionDetailsValidationError{
					field:  "StoreAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionDetailsValidationError{
					field:  "StoreAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStoreAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionDetailsValidationError{
				field:  "StoreAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetLineItems()) < 1 {
		err := TransactionDetailsValidationError{
			field:  "LineItems",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionDetailsValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionDetailsValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionDetailsMultiError(errors)
	}

	return nil
}

// TransactionDetailsMultiError is an error wrapping multiple validation errors
// returned by TransactionDetails.ValidateAll() if the designated constraints
// aren't met.
type TransactionDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionDetailsMultiError) AllErrors() []error { return m }

// TransactionDetailsValidationError is the validation error returned by
// TransactionDetails.Validate if the designated constraints aren't met.
type TransactionDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionDetailsValidationError) ErrorName() string {
	return "TransactionDetailsValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionDetailsValidationError{}

// Validate checks the field values on Discount with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Discount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Discount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiscountMultiError, or nil
// if none found.
func (m *Discount) ValidateAll() error {
	return m.validate(true)
}

func (m *Discount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDiscountDefinitionKey()); l < 30 || l > 50 {
		err := DiscountValidationError{
			field:  "DiscountDefinitionKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDiscountDefinitionRef()); l < 1 || l > 50 {
		err := DiscountValidationError{
			field:  "DiscountDefinitionRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
		err := DiscountValidationError{
			field:  "DiscountKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetVersion() < 0 {
		err := DiscountValidationError{
			field:  "Version",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscountValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "Updated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "Updated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscountValidationError{
				field:  "Updated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
		err := DiscountValidationError{
			field:  "DiscountRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetHeadline()) > 100 {
		err := DiscountValidationError{
			field:  "Headline",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetSummary()) > 300 {
		err := DiscountValidationError{
			field:  "Summary",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetThumbnailUrl()) > 300 {
		err := DiscountValidationError{
			field:  "ThumbnailUrl",
			reason: "value length must be at most 300 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReceiptDescription()) > 100 {
		err := DiscountValidationError{
			field:  "ReceiptDescription",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for Type

	if t := m.GetValidTo(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = DiscountValidationError{
				field:  "ValidTo",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) <= 0 {
				err := DiscountValidationError{
					field:  "ValidTo",
					reason: "value must be greater than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	for idx, item := range m.GetDiscountCriteria() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscountValidationError{
					field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Currency

	if l := utf8.RuneCountInString(m.GetUserKey()); l < 30 || l > 50 {
		err := DiscountValidationError{
			field:  "UserKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUserRef()); l < 1 || l > 50 {
		err := DiscountValidationError{
			field:  "UserRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransactionDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "TransactionDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscountValidationError{
					field:  "TransactionDetails",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscountValidationError{
				field:  "TransactionDetails",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.DiscountAmount.(type) {
	case *Discount_MonetaryAmount:
		if v == nil {
			err := DiscountValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMonetaryAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMonetaryAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscountValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Discount_PercentageAmount:
		if v == nil {
			err := DiscountValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPercentageAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DiscountValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercentageAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DiscountValidationError{
					field:  "PercentageAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DiscountMultiError(errors)
	}

	return nil
}

// DiscountMultiError is an error wrapping multiple validation errors returned
// by Discount.ValidateAll() if the designated constraints aren't met.
type DiscountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscountMultiError) AllErrors() []error { return m }

// DiscountValidationError is the validation error returned by
// Discount.Validate if the designated constraints aren't met.
type DiscountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscountValidationError) ErrorName() string { return "DiscountValidationError" }

// Error satisfies the builtin error interface
func (e DiscountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscountValidationError{}

// Validate checks the field values on Quantity with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Quantity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Quantity with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuantityMultiError, or nil
// if none found.
func (m *Quantity) ValidateAll() error {
	return m.validate(true)
}

func (m *Quantity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Quantity

	// no validation rules for Unit

	if len(errors) > 0 {
		return QuantityMultiError(errors)
	}

	return nil
}

// QuantityMultiError is an error wrapping multiple validation errors returned
// by Quantity.ValidateAll() if the designated constraints aren't met.
type QuantityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuantityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuantityMultiError) AllErrors() []error { return m }

// QuantityValidationError is the validation error returned by
// Quantity.Validate if the designated constraints aren't met.
type QuantityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuantityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuantityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuantityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuantityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuantityValidationError) ErrorName() string { return "QuantityValidationError" }

// Error satisfies the builtin error interface
func (e QuantityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuantity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuantityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuantityValidationError{}

// Validate checks the field values on DiscountCriteria with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiscountCriteria) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiscountCriteria with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiscountCriteriaMultiError, or nil if none found.
func (m *DiscountCriteria) ValidateAll() error {
	return m.validate(true)
}

func (m *DiscountCriteria) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuantity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscountCriteriaValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscountCriteriaValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscountCriteriaValidationError{
				field:  "Quantity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMonetaryAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiscountCriteriaValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiscountCriteriaValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMonetaryAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiscountCriteriaValidationError{
				field:  "MonetaryAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DiscountAmountApplicable

	if len(m.GetProductGroupRefs()) > 100 {
		err := DiscountCriteriaValidationError{
			field:  "ProductGroupRefs",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetProductMatchFilters()) > 100 {
		err := DiscountCriteriaValidationError{
			field:  "ProductMatchFilters",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetProductCodes()) > 100 {
		err := DiscountCriteriaValidationError{
			field:  "ProductCodes",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DiscountCriteriaMultiError(errors)
	}

	return nil
}

// DiscountCriteriaMultiError is an error wrapping multiple validation errors
// returned by DiscountCriteria.ValidateAll() if the designated constraints
// aren't met.
type DiscountCriteriaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiscountCriteriaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiscountCriteriaMultiError) AllErrors() []error { return m }

// DiscountCriteriaValidationError is the validation error returned by
// DiscountCriteria.Validate if the designated constraints aren't met.
type DiscountCriteriaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiscountCriteriaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiscountCriteriaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiscountCriteriaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiscountCriteriaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiscountCriteriaValidationError) ErrorName() string { return "DiscountCriteriaValidationError" }

// Error satisfies the builtin error interface
func (e DiscountCriteriaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiscountCriteria.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiscountCriteriaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiscountCriteriaValidationError{}

// Validate checks the field values on MonetaryAmount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MonetaryAmount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonetaryAmount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MonetaryAmountMultiError,
// or nil if none found.
func (m *MonetaryAmount) ValidateAll() error {
	return m.validate(true)
}

func (m *MonetaryAmount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Amount

	// no validation rules for TaxAmount

	if len(errors) > 0 {
		return MonetaryAmountMultiError(errors)
	}

	return nil
}

// MonetaryAmountMultiError is an error wrapping multiple validation errors
// returned by MonetaryAmount.ValidateAll() if the designated constraints
// aren't met.
type MonetaryAmountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonetaryAmountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonetaryAmountMultiError) AllErrors() []error { return m }

// MonetaryAmountValidationError is the validation error returned by
// MonetaryAmount.Validate if the designated constraints aren't met.
type MonetaryAmountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonetaryAmountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonetaryAmountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonetaryAmountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonetaryAmountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonetaryAmountValidationError) ErrorName() string { return "MonetaryAmountValidationError" }

// Error satisfies the builtin error interface
func (e MonetaryAmountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonetaryAmount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonetaryAmountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonetaryAmountValidationError{}

// Validate checks the field values on PercentageAmount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PercentageAmount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PercentageAmount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PercentageAmountMultiError, or nil if none found.
func (m *PercentageAmount) ValidateAll() error {
	return m.validate(true)
}

func (m *PercentageAmount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PercentageAmount

	// no validation rules for PercentageTaxAmount

	if all {
		switch v := interface{}(m.GetMaxAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PercentageAmountValidationError{
					field:  "MaxAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PercentageAmountValidationError{
					field:  "MaxAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PercentageAmountValidationError{
				field:  "MaxAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PercentageAmountMultiError(errors)
	}

	return nil
}

// PercentageAmountMultiError is an error wrapping multiple validation errors
// returned by PercentageAmount.ValidateAll() if the designated constraints
// aren't met.
type PercentageAmountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PercentageAmountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PercentageAmountMultiError) AllErrors() []error { return m }

// PercentageAmountValidationError is the validation error returned by
// PercentageAmount.Validate if the designated constraints aren't met.
type PercentageAmountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PercentageAmountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PercentageAmountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PercentageAmountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PercentageAmountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PercentageAmountValidationError) ErrorName() string { return "PercentageAmountValidationError" }

// Error satisfies the builtin error interface
func (e PercentageAmountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPercentageAmount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PercentageAmountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PercentageAmountValidationError{}

// Validate checks the field values on CreateDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDiscountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDiscountRequestMultiError, or nil if none found.
func (m *CreateDiscountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDiscountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDiscountDefinitionRef()); l < 1 || l > 50 {
		err := CreateDiscountRequestValidationError{
			field:  "DiscountDefinitionRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
		err := CreateDiscountRequestValidationError{
			field:  "DiscountRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReceiptDescription()) > 100 {
		err := CreateDiscountRequestValidationError{
			field:  "ReceiptDescription",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateDiscountRequest_Status_NotInLookup[m.GetStatus()]; ok {
		err := CreateDiscountRequestValidationError{
			field:  "Status",
			reason: "value must not be in list [DISCOUNT_STATUS_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if t := m.GetValidTo(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = CreateDiscountRequestValidationError{
				field:  "ValidTo",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) <= 0 {
				err := CreateDiscountRequestValidationError{
					field:  "ValidTo",
					reason: "value must be greater than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	for idx, item := range m.GetDiscountCriteria() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDiscountRequestValidationError{
					field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if l := utf8.RuneCountInString(m.GetUserKey()); l < 30 || l > 50 {
		err := CreateDiscountRequestValidationError{
			field:  "UserKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUserRef()); l < 1 || l > 50 {
		err := CreateDiscountRequestValidationError{
			field:  "UserRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.DiscountAmount.(type) {
	case *CreateDiscountRequest_MonetaryAmount:
		if v == nil {
			err := CreateDiscountRequestValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMonetaryAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMonetaryAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDiscountRequestValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateDiscountRequest_PercentageAmount:
		if v == nil {
			err := CreateDiscountRequestValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPercentageAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDiscountRequestValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercentageAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDiscountRequestValidationError{
					field:  "PercentageAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CreateDiscountRequestMultiError(errors)
	}

	return nil
}

// CreateDiscountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDiscountRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDiscountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDiscountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDiscountRequestMultiError) AllErrors() []error { return m }

// CreateDiscountRequestValidationError is the validation error returned by
// CreateDiscountRequest.Validate if the designated constraints aren't met.
type CreateDiscountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDiscountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDiscountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDiscountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDiscountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDiscountRequestValidationError) ErrorName() string {
	return "CreateDiscountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDiscountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDiscountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDiscountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDiscountRequestValidationError{}

var _CreateDiscountRequest_Status_NotInLookup = map[DiscountStatus]struct{}{
	0: {},
}

// Validate checks the field values on CreateDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDiscountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDiscountResponseMultiError, or nil if none found.
func (m *CreateDiscountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDiscountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDiscountResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DiscountKey

	if m.GetVersion() < 0 {
		err := CreateDiscountResponseValidationError{
			field:  "Version",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateDiscountResponseMultiError(errors)
	}

	return nil
}

// CreateDiscountResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDiscountResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDiscountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDiscountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDiscountResponseMultiError) AllErrors() []error { return m }

// CreateDiscountResponseValidationError is the validation error returned by
// CreateDiscountResponse.Validate if the designated constraints aren't met.
type CreateDiscountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDiscountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDiscountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDiscountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDiscountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDiscountResponseValidationError) ErrorName() string {
	return "CreateDiscountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDiscountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDiscountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDiscountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDiscountResponseValidationError{}

// Validate checks the field values on GetDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDiscountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDiscountRequestMultiError, or nil if none found.
func (m *GetDiscountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDiscountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.DiscountIdentifier.(type) {
	case *GetDiscountRequest_DiscountRef:
		if v == nil {
			err := GetDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
			err := GetDiscountRequestValidationError{
				field:  "DiscountRef",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *GetDiscountRequest_DiscountKey:
		if v == nil {
			err := GetDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
			err := GetDiscountRequestValidationError{
				field:  "DiscountKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GetDiscountRequestMultiError(errors)
	}

	return nil
}

// GetDiscountRequestMultiError is an error wrapping multiple validation errors
// returned by GetDiscountRequest.ValidateAll() if the designated constraints
// aren't met.
type GetDiscountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDiscountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDiscountRequestMultiError) AllErrors() []error { return m }

// GetDiscountRequestValidationError is the validation error returned by
// GetDiscountRequest.Validate if the designated constraints aren't met.
type GetDiscountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDiscountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDiscountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDiscountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDiscountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDiscountRequestValidationError) ErrorName() string {
	return "GetDiscountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDiscountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDiscountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDiscountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDiscountRequestValidationError{}

// Validate checks the field values on GetDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDiscountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDiscountResponseMultiError, or nil if none found.
func (m *GetDiscountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDiscountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDiscountResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDiscount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDiscountResponseValidationError{
					field:  "Discount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDiscountResponseValidationError{
					field:  "Discount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDiscount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDiscountResponseValidationError{
				field:  "Discount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDiscountResponseMultiError(errors)
	}

	return nil
}

// GetDiscountResponseMultiError is an error wrapping multiple validation
// errors returned by GetDiscountResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDiscountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDiscountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDiscountResponseMultiError) AllErrors() []error { return m }

// GetDiscountResponseValidationError is the validation error returned by
// GetDiscountResponse.Validate if the designated constraints aren't met.
type GetDiscountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDiscountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDiscountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDiscountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDiscountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDiscountResponseValidationError) ErrorName() string {
	return "GetDiscountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDiscountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDiscountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDiscountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDiscountResponseValidationError{}

// Validate checks the field values on UpdateDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDiscountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDiscountRequestMultiError, or nil if none found.
func (m *UpdateDiscountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDiscountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetVersion() < 0 {
		err := UpdateDiscountRequestValidationError{
			field:  "Version",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetReceiptDescription()) > 100 {
		err := UpdateDiscountRequestValidationError{
			field:  "ReceiptDescription",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateDiscountRequest_Status_NotInLookup[m.GetStatus()]; ok {
		err := UpdateDiscountRequestValidationError{
			field:  "Status",
			reason: "value must not be in list [DISCOUNT_STATUS_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if t := m.GetValidTo(); t != nil {
		ts, err := t.AsTime(), t.CheckValid()
		if err != nil {
			err = UpdateDiscountRequestValidationError{
				field:  "ValidTo",
				reason: "value is not a valid timestamp",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			now := time.Now()

			if ts.Sub(now) <= 0 {
				err := UpdateDiscountRequestValidationError{
					field:  "ValidTo",
					reason: "value must be greater than now",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	for idx, item := range m.GetDiscountCriteria() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDiscountRequestValidationError{
					field:  fmt.Sprintf("DiscountCriteria[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for UserKey

	if l := utf8.RuneCountInString(m.GetUserRef()); l < 1 || l > 50 {
		err := UpdateDiscountRequestValidationError{
			field:  "UserRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.DiscountIdentifier.(type) {
	case *UpdateDiscountRequest_DiscountRef:
		if v == nil {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountRef",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *UpdateDiscountRequest_DiscountKey:
		if v == nil {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.DiscountAmount.(type) {
	case *UpdateDiscountRequest_MonetaryAmount:
		if v == nil {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMonetaryAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  "MonetaryAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMonetaryAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDiscountRequestValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *UpdateDiscountRequest_PercentageAmount:
		if v == nil {
			err := UpdateDiscountRequestValidationError{
				field:  "DiscountAmount",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPercentageAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateDiscountRequestValidationError{
						field:  "PercentageAmount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPercentageAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateDiscountRequestValidationError{
					field:  "PercentageAmount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return UpdateDiscountRequestMultiError(errors)
	}

	return nil
}

// UpdateDiscountRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDiscountRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateDiscountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDiscountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDiscountRequestMultiError) AllErrors() []error { return m }

// UpdateDiscountRequestValidationError is the validation error returned by
// UpdateDiscountRequest.Validate if the designated constraints aren't met.
type UpdateDiscountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDiscountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDiscountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDiscountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDiscountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDiscountRequestValidationError) ErrorName() string {
	return "UpdateDiscountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDiscountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDiscountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDiscountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDiscountRequestValidationError{}

var _UpdateDiscountRequest_Status_NotInLookup = map[DiscountStatus]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDiscountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDiscountResponseMultiError, or nil if none found.
func (m *UpdateDiscountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDiscountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDiscountResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetVersion() < 0 {
		err := UpdateDiscountResponseValidationError{
			field:  "Version",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDiscountResponseMultiError(errors)
	}

	return nil
}

// UpdateDiscountResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDiscountResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateDiscountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDiscountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDiscountResponseMultiError) AllErrors() []error { return m }

// UpdateDiscountResponseValidationError is the validation error returned by
// UpdateDiscountResponse.Validate if the designated constraints aren't met.
type UpdateDiscountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDiscountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDiscountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDiscountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDiscountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDiscountResponseValidationError) ErrorName() string {
	return "UpdateDiscountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDiscountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDiscountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDiscountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDiscountResponseValidationError{}

// Validate checks the field values on UpdateDiscountStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDiscountStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDiscountStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDiscountStatusRequestMultiError, or nil if none found.
func (m *UpdateDiscountStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDiscountStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateDiscountStatusRequest_DiscountStatus_NotInLookup[m.GetDiscountStatus()]; ok {
		err := UpdateDiscountStatusRequestValidationError{
			field:  "DiscountStatus",
			reason: "value must not be in list [DISCOUNT_STATUS_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.DiscountIdentifier.(type) {
	case *UpdateDiscountStatusRequest_DiscountRef:
		if v == nil {
			err := UpdateDiscountStatusRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
			err := UpdateDiscountStatusRequestValidationError{
				field:  "DiscountRef",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *UpdateDiscountStatusRequest_DiscountKey:
		if v == nil {
			err := UpdateDiscountStatusRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
			err := UpdateDiscountStatusRequestValidationError{
				field:  "DiscountKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return UpdateDiscountStatusRequestMultiError(errors)
	}

	return nil
}

// UpdateDiscountStatusRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDiscountStatusRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDiscountStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDiscountStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDiscountStatusRequestMultiError) AllErrors() []error { return m }

// UpdateDiscountStatusRequestValidationError is the validation error returned
// by UpdateDiscountStatusRequest.Validate if the designated constraints
// aren't met.
type UpdateDiscountStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDiscountStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDiscountStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDiscountStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDiscountStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDiscountStatusRequestValidationError) ErrorName() string {
	return "UpdateDiscountStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDiscountStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDiscountStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDiscountStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDiscountStatusRequestValidationError{}

var _UpdateDiscountStatusRequest_DiscountStatus_NotInLookup = map[DiscountStatus]struct{}{
	0: {},
}

// Validate checks the field values on UpdateDiscountStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDiscountStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDiscountStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDiscountStatusResponseMultiError, or nil if none found.
func (m *UpdateDiscountStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDiscountStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateDiscountStatusResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateDiscountStatusResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateDiscountStatusResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetVersion() < 0 {
		err := UpdateDiscountStatusResponseValidationError{
			field:  "Version",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDiscountStatusResponseMultiError(errors)
	}

	return nil
}

// UpdateDiscountStatusResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDiscountStatusResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateDiscountStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDiscountStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDiscountStatusResponseMultiError) AllErrors() []error { return m }

// UpdateDiscountStatusResponseValidationError is the validation error returned
// by UpdateDiscountStatusResponse.Validate if the designated constraints
// aren't met.
type UpdateDiscountStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDiscountStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDiscountStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDiscountStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDiscountStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDiscountStatusResponseValidationError) ErrorName() string {
	return "UpdateDiscountStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDiscountStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDiscountStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDiscountStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDiscountStatusResponseValidationError{}

// Validate checks the field values on RemoveDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveDiscountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveDiscountRequestMultiError, or nil if none found.
func (m *RemoveDiscountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveDiscountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.DiscountIdentifier.(type) {
	case *RemoveDiscountRequest_DiscountRef:
		if v == nil {
			err := RemoveDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
			err := RemoveDiscountRequestValidationError{
				field:  "DiscountRef",
				reason: "value length must be between 1 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *RemoveDiscountRequest_DiscountKey:
		if v == nil {
			err := RemoveDiscountRequestValidationError{
				field:  "DiscountIdentifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
			err := RemoveDiscountRequestValidationError{
				field:  "DiscountKey",
				reason: "value length must be between 30 and 50 runes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RemoveDiscountRequestMultiError(errors)
	}

	return nil
}

// RemoveDiscountRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveDiscountRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveDiscountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveDiscountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveDiscountRequestMultiError) AllErrors() []error { return m }

// RemoveDiscountRequestValidationError is the validation error returned by
// RemoveDiscountRequest.Validate if the designated constraints aren't met.
type RemoveDiscountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveDiscountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveDiscountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveDiscountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveDiscountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveDiscountRequestValidationError) ErrorName() string {
	return "RemoveDiscountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveDiscountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveDiscountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveDiscountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveDiscountRequestValidationError{}

// Validate checks the field values on RemoveDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveDiscountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveDiscountResponseMultiError, or nil if none found.
func (m *RemoveDiscountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveDiscountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveDiscountResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RemoveDiscountResponseMultiError(errors)
	}

	return nil
}

// RemoveDiscountResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveDiscountResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveDiscountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveDiscountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveDiscountResponseMultiError) AllErrors() []error { return m }

// RemoveDiscountResponseValidationError is the validation error returned by
// RemoveDiscountResponse.Validate if the designated constraints aren't met.
type RemoveDiscountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveDiscountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveDiscountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveDiscountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveDiscountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveDiscountResponseValidationError) ErrorName() string {
	return "RemoveDiscountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveDiscountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveDiscountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveDiscountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveDiscountResponseValidationError{}

// Validate checks the field values on ApplyDiscountNotificationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplyDiscountNotificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyDiscountNotificationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApplyDiscountNotificationRequestMultiError, or nil if none found.
func (m *ApplyDiscountNotificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyDiscountNotificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetDiscountKey()); l < 30 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "DiscountKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetDiscountRef()); l < 1 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "DiscountRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Status

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetMonetaryAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "MonetaryAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMonetaryAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDiscountNotificationRequestValidationError{
				field:  "MonetaryAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetTransactionKey()); l < 30 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "TransactionKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTransactionCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "TransactionCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "TransactionCreated",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDiscountNotificationRequestValidationError{
				field:  "TransactionCreated",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetPartnerKey()); l < 30 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "PartnerKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPartnerName()); l < 1 || l > 100 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "PartnerName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOrganizationKey()); l < 30 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "OrganizationKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetOrganizationName()) > 100 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "OrganizationName",
			reason: "value length must be at most 100 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOrganizationAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "OrganizationAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "OrganizationAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrganizationAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDiscountNotificationRequestValidationError{
				field:  "OrganizationAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetStoreKey()); l < 30 || l > 50 {
		err := ApplyDiscountNotificationRequestValidationError{
			field:  "StoreKey",
			reason: "value length must be between 30 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for StoreNumber

	if all {
		switch v := interface{}(m.GetStoreAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "StoreAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDiscountNotificationRequestValidationError{
					field:  "StoreAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStoreAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDiscountNotificationRequestValidationError{
				field:  "StoreAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyDiscountNotificationRequestValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyDiscountNotificationRequestValidationError{
						field:  fmt.Sprintf("LineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyDiscountNotificationRequestValidationError{
					field:  fmt.Sprintf("LineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApplyDiscountNotificationRequestMultiError(errors)
	}

	return nil
}

// ApplyDiscountNotificationRequestMultiError is an error wrapping multiple
// validation errors returned by
// ApplyDiscountNotificationRequest.ValidateAll() if the designated
// constraints aren't met.
type ApplyDiscountNotificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyDiscountNotificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyDiscountNotificationRequestMultiError) AllErrors() []error { return m }

// ApplyDiscountNotificationRequestValidationError is the validation error
// returned by ApplyDiscountNotificationRequest.Validate if the designated
// constraints aren't met.
type ApplyDiscountNotificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyDiscountNotificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyDiscountNotificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyDiscountNotificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyDiscountNotificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyDiscountNotificationRequestValidationError) ErrorName() string {
	return "ApplyDiscountNotificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyDiscountNotificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyDiscountNotificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyDiscountNotificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyDiscountNotificationRequestValidationError{}

// Validate checks the field values on ApplyDiscountNotificationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplyDiscountNotificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyDiscountNotificationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ApplyDiscountNotificationResponseMultiError, or nil if none found.
func (m *ApplyDiscountNotificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyDiscountNotificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApplyDiscountNotificationResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApplyDiscountNotificationResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApplyDiscountNotificationResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := utf8.RuneCountInString(m.GetExternalRef()); l < 1 || l > 50 {
		err := ApplyDiscountNotificationResponseValidationError{
			field:  "ExternalRef",
			reason: "value length must be between 1 and 50 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApplyDiscountNotificationResponseMultiError(errors)
	}

	return nil
}

// ApplyDiscountNotificationResponseMultiError is an error wrapping multiple
// validation errors returned by
// ApplyDiscountNotificationResponse.ValidateAll() if the designated
// constraints aren't met.
type ApplyDiscountNotificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyDiscountNotificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyDiscountNotificationResponseMultiError) AllErrors() []error { return m }

// ApplyDiscountNotificationResponseValidationError is the validation error
// returned by ApplyDiscountNotificationResponse.Validate if the designated
// constraints aren't met.
type ApplyDiscountNotificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyDiscountNotificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyDiscountNotificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyDiscountNotificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyDiscountNotificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyDiscountNotificationResponseValidationError) ErrorName() string {
	return "ApplyDiscountNotificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyDiscountNotificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyDiscountNotificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyDiscountNotificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyDiscountNotificationResponseValidationError{}

// Validate checks the field values on SearchDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchDiscountRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchDiscountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchDiscountRequestMultiError, or nil if none found.
func (m *SearchDiscountRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchDiscountRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DiscountDefinitionRef

	// no validation rules for ReceiptDescription

	// no validation rules for Status

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetValidFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchDiscountRequestValidationError{
					field:  "ValidFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchDiscountRequestValidationError{
					field:  "ValidFrom",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchDiscountRequestValidationError{
				field:  "ValidFrom",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValidTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchDiscountRequestValidationError{
					field:  "ValidTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchDiscountRequestValidationError{
					field:  "ValidTo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchDiscountRequestValidationError{
				field:  "ValidTo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for UserRef

	if len(errors) > 0 {
		return SearchDiscountRequestMultiError(errors)
	}

	return nil
}

// SearchDiscountRequestMultiError is an error wrapping multiple validation
// errors returned by SearchDiscountRequest.ValidateAll() if the designated
// constraints aren't met.
type SearchDiscountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchDiscountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchDiscountRequestMultiError) AllErrors() []error { return m }

// SearchDiscountRequestValidationError is the validation error returned by
// SearchDiscountRequest.Validate if the designated constraints aren't met.
type SearchDiscountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchDiscountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchDiscountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchDiscountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchDiscountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchDiscountRequestValidationError) ErrorName() string {
	return "SearchDiscountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SearchDiscountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchDiscountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchDiscountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchDiscountRequestValidationError{}

// Validate checks the field values on SearchDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SearchDiscountResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchDiscountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SearchDiscountResponseMultiError, or nil if none found.
func (m *SearchDiscountResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchDiscountResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SearchDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SearchDiscountResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SearchDiscountResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDiscounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchDiscountResponseValidationError{
						field:  fmt.Sprintf("Discounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchDiscountResponseValidationError{
						field:  fmt.Sprintf("Discounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchDiscountResponseValidationError{
					field:  fmt.Sprintf("Discounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchDiscountResponseMultiError(errors)
	}

	return nil
}

// SearchDiscountResponseMultiError is an error wrapping multiple validation
// errors returned by SearchDiscountResponse.ValidateAll() if the designated
// constraints aren't met.
type SearchDiscountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchDiscountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchDiscountResponseMultiError) AllErrors() []error { return m }

// SearchDiscountResponseValidationError is the validation error returned by
// SearchDiscountResponse.Validate if the designated constraints aren't met.
type SearchDiscountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchDiscountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchDiscountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchDiscountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchDiscountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchDiscountResponseValidationError) ErrorName() string {
	return "SearchDiscountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SearchDiscountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchDiscountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchDiscountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchDiscountResponseValidationError{}
